/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab02;

import java.util.*;

public class Library {

    public static int[] roll(int n) {

        int[] arrayResult = new int[n];

//        ArrayList<Integer> arrayResult = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int diceFace = (int) Math.ceil(Math.random() * 6);
//            arrayResult.add(diceFace);
            arrayResult[i] = diceFace;
        }

        // print array one method
        System.out.println(Arrays.toString(arrayResult));

        // print array second method
        for (int i = 0; i < n; i++) {
            System.out.print(arrayResult[i] + ", ");
        }

        System.out.println("\n");
        return arrayResult;
    }

    public static boolean containsDuplicates(int[] arr) {
//        for (int i = 0; i < arr.length; i++) {
//
//            for (int j = i+1; j < arr.length; j++) {
//                if (arr[i] == arr[j]) {
//                    System.out.println("true");
//                    break;
//                }else {
//                    System.out.println("false");
//
//                }
//
//            }
//
//        }
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    return true;
                }
            }
        }

        // no duplicate is found
        return false;
    }

    public static double average(int[] array) {
        double sum = 0;
        for (int value : array) {
            sum += value;
        }

        return sum / array.length;
    }

    public static int[] arraysLowestAav(int[][] arr) {

//        ArrayList <Double> avarges = new ArrayList<>();
        double[] avarges = new double[arr.length];

        double finalAv = 0;
        for (int i = 0; i < arr.length; i++) {
            double sum = 0;
            double arrLength = 0;
            for (int j = 0; j < arr[i].length; j++) {


                sum += arr[i][j];


            }


            avarges[i] = sum / arr[i].length;

        }
        finalAv = avarges[0];
        int selsctedArray = 0;
        for (int i = 1; i < avarges.length; i++) {


            if (avarges[i] < finalAv) {
                finalAv = avarges[i];
                selsctedArray = i;
            }

        }
        return arr[selsctedArray];
    }

    public boolean someLibraryMethod() {
        return true;

    }

    public static void weatherData(int[][] arr) {

        HashSet<Integer> weatherTemp = new HashSet<>();
              String [] results;
        for (int[] item : arr) {
            for (int temp : item) {
                weatherTemp.add(temp);

            }
        }



        int min = Collections.min(weatherTemp);
        int max = Collections.max(weatherTemp);



        System.out.println("\n"+"High:  "+max);
        System.out.println("low:  "+min+"\n");

        for (int i = min; i < max; i++) {
            if (!weatherTemp.contains(i))
            System.out.println("Never saw temperature: "+i+"\n");
        }


    }


    public static String tally(List<String> votes) {


        HashSet<String> votedName = new HashSet<>();

        votedName.addAll(votes);

        int numOfVotes = 0;
        String winnerName = null;


        for (String name : votedName) {

            int count = Collections.frequency(votes, name);

            if (numOfVotes < count) {
                numOfVotes = count;

//                winnerName = String.format("%s received the most votes!", item);
                winnerName = "\n" + name + " received the most votes!\n";
            }
        }

        return winnerName;
    }
    // Returns index of x if it is present in arr[l..
    // r], else return -1
//    int binarySearch(int arr[],  int x)
//    {
//        int first =0;
//        int last = arr.length-1;
//        if (last >= first) {
//            int mid =  last + first / 2;
//
//            // If the element is present at the
//            // middle itself
//            if (arr[mid] == x)
//                return mid;
//
//            // If element is smaller than mid, then
//            // it can only be present in left subarray
//            if (arr[mid] > x) {
//                last = mid - 1;
//                return binarySearch(arr, x);
//            }
//            // Else the element can only be present
//            // in right subarray
//            else {
//                first=mid+1;
//                return binarySearch(arr, x);
//            }
//        }

    // We reach here when element is not present
    // in array
//        return -1;
//    }
    public static int BinarySearch(int[] arr, int n) {
        int left = 0;
        int mid;
        int right = arr.length - 1;

        while (left <= right) {
            mid = right + left / 2;

            if (n == arr[mid]) {
                return mid;
            } else if (n < arr[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }


//    public static String analyzeWeathrData(int[][] data) {
//        HashSet<Integer> uniqueTempData = new HashSet<>();
//        for (int i = 0; i < data.length; i++) {
//            for (Integer temp : data[i]) {
//                uniqueTempData.add(temp);
//            }
//        }
////        System.out.println("Low Temperature " + Collections.min(uniqueTempData));
//        String lowTemp = "Low Temperature " + Collections.min(uniqueTempData);
////        System.out.println("High Temperature " + Collections.max(uniqueTempData));
//        String highTemp = "\nHigh Temperature " + Collections.max(uniqueTempData);
//        String neverSaw = "";
//        for (int i = Collections.min(uniqueTempData); i < Collections.max(uniqueTempData); i++) {
//            if (!uniqueTempData.contains(i)) {
////                System.out.println("Never saw temperature: " + i);
//                neverSaw += "\nNever saw temperature: " + i;
//
//            }
//        }
//        return lowTemp + highTemp + neverSaw;
//
//    }


}


